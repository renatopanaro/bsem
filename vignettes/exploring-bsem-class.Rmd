---
title: "Exploring bsem class"
subtitle: "How to get information from the bsem package outcomes"
author: 
  - name          : "Renato Panaro"
keywords          : "sem, posterior, diagram, summary, plot"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
      toc_number: true
vignette: >
  %\VignetteIndexEntry{Exploring bsem class}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

<style>
body {
text-align: justify
</style>

# Examples

This vignette describes how the package can be used to estimate artificial parameters. This is a former analysis in light of other studies based on replication such as Monte Carlo simulation study methods. There are two ways to specify a ``sem`` model: 

1. the blocks, paths, exogenous, and the data set are not named by the user (internally named);

2. named list are passed to their respective arguments and consequently to the automated plot function.
  
## CFA 

The implemented routines allow semi or full confirmatory factor analysis (CFA). Thus, at least one variable must be chosen to express each construct before running into the analysis. In other words, the user needs to specify at least one manifest variable that leads each block. In this way, semi-confirmatory FA assists the researcher in evidencing the possible structures to be tested in a conceptual (full) CFA later on. The function `bsem::simdata` is used to generate the simulated data. This routine internally produces artificial variances that are used to generate normally distributed errors. Factor scores (lambda) are generated from a standard normal distribution and the factor loadings (alpha) from a uniform distribution with support ranging from 0.5 to 2. The factor loading direction is generated using signals simulated from the `sample` function. A new artificial data set is produced with the command below:

```{r}
dt3 <- bsem::simdata(paths = NULL, 
                     exogenous = NULL)
```

The `paths` and` exogenous` arguments must be defined as `NULL` to obtain a data set suitable for factor analysis. Now we can run `bsem::sem` to check whether the `bsem::sem` retrieve estimates close to the real values of the parameters. 

- A list of blocks is always necessary to represent the manifest variables related to each construct of the outer model:

```{r}
dt3$blocks
```


- Descriptive statistics for the posterior factor loadings are showed in the result in `rstan` fashion (based on ``rstan::monitor``):

```{r}
cfa <- bsem::sem(data = dt3$data,
                       blocks = dt3$blocks
                       )
```

A warning is displayed in the direction of the outer model loadings that are not specified. In this case, random values are assigned.
Descriptive statistics for the posterior factor loadings are shown in the R console inspired on the `rstan` fashion (based on ``rstan::monitor``). In general, the posterior mean is the Bayesian estimator first choice.

- The structural model can be easily viewed with the plotting routine `bsem::plot`:

```{r, echo = F}
plot(cfa)
```

The recursive arrows indicate the estimate for each error variance. From this example, we found that the estimates pattern is tightly close to the true values of the parameters even when the signals are not passed. Also, we have observed that the part of the analysis is intended to confirm the predefined constructs CFA (first loadings matrix lines) and the other is intended to express which variable can compose a later full CFA.

Moreover, we can compare the posterior factor loadings and the scores with the true values using the `bsem::arrayplot` function. For example:

```{r, echo = F}
gridExtra::grid.arrange(
  bsem::arrayplot(cfa$mean_lambda, main = "estimates", -4, 4),
  bsem::arrayplot(dt3$real$lambda, main = "lambda (scores)", -4, 4),
  bsem::arrayplot(cfa$mean_alpha, main = "estimates", -4, 4),
  bsem::arrayplot(dt3$real$alpha, main = "alpha (loadings)", -4, 4),
  layout_matrix = matrix(c(1, 1, 3, 3, 2, 2, 4, 4), ncol = 2)
)
```

The ``bsem::arrayplot`` graphs show that the loadings and scores pattern was captured by the model. To get closer estimates it may be necessary to increase the number of iterations or the warmup period since this is a model with many parameters.

```{r, echo = F}
loadings_names <- rownames(cfa$mean_alpha)
find <- paste0("alpha[", which(loadings_names %in% unlist(cfa$blocks)), ",", rep(1:length(cfa$blocks), lengths(cfa$blocks)), "]")

bayesplot::mcmc_trace(cfa$posterior$alpha[, , find])
```

Remember each chain runs in a separate thread, thus, it is recommended specifying the number of cores at least equal to the number of chains. Indeed, from our experience, an increase in the number of iterations raises the runtime but considerably improves the interval and point estimates. 


## SEM

For this model we will use the simulated data already described in the [Get started](bsem.html) vignette. This model includes variables that are explained by some common factors, those variables are referred to as the exogenous variables.

```{r}
dt <- bsem::simdata()
```

```{r}
sem <- bsem::sem(data = dt$data,
                       blocks = dt$blocks,
                       paths = dt$paths,
                       exogenous = dt$exogenous
                       )
```

Similar outcomes can be also obtained for this model:

```{r, echo = F}
plot(sem)
```

```{r, echo = F}
gridExtra::grid.arrange(
  bsem::arrayplot(sem$mean_lambda, main = "estimates", -4, 4),
  bsem::arrayplot(dt$real$lambda, main = "lambda (scores)", -4, 4),
  bsem::arrayplot(sem$mean_alpha, main = "estimates", -4, 4),
  bsem::arrayplot(dt$real$alpha, main = "alpha (loadings)", -4, 4),
  layout_matrix = matrix(c(1, 1, 3, 3, 2, 2, 4, 4), ncol = 2)
)
```

```{r, echo = F}
loadings_names <- rownames(sem$mean_alpha)
find <- paste0("alpha[", which(loadings_names %in% unlist(sem$blocks)), ",", rep(1:length(cfa$blocks), lengths(sem$blocks)), "]")
bayesplot::mcmc_trace(sem$posterior$alpha[, , find])
```

# Graphical posterior analysis 

The first thing to do after fitting the model is to check posterior statistics to assess whether the estimates are good to describe the proposed CFA or SEM model.

## Interval estimate

Two types of intervals can be obtained:  

### HPD interval  
- The narrowest (highest posterior density - HPD) credibility interval can be retrieved using `.$credint`. We have computed HPD intervals fo the factor loadings (alpha), scores (lambda), and regression coefficients (beta).

```{r}
names(cfa$credint)
```

- This data can be used to plot interval estimates using two packages, `ggplot2` and `tidybayes`:

```{r, results = F, message = F, warning= F} 
library("ggplot2")
library("tidybayes")
```

- `dt` data.frame object has the mean loadings and the HPD interval lower and upper limits (`ll` and `lu`):

```{r}
dt <- data.frame(
  li = cfa$credint$alpha[, 1],
  lu = cfa$credint$alpha[, 2],
  m = c(cfa$mean_alpha)
)
```

- `lnames` and `snames` are used to find the loadings of the conceptual model (those that might not equal zero).

```{r}
lnames <- rownames(cfa$mean_alpha)
snames <- rownames(cfa$mean_lambda)
```

- `find` help us finding these values:

```{r}
find <- paste0("alpha[", which(lnames %in% unlist(cfa$blocks)), ",", rep(1:length(cfa$blocks), lengths(cfa$blocks)), "]")

dt <- dt[find, ]
```

- One of the options to plot the loadings HPD intervals chart is:
```{r}
ggplot(aes(y = find, x = m, xmin = li, xmax = lu), data = dt) +
  geom_pointintervalh() +
  theme_classic() +
  labs(
    title = paste("Latent variable", colnames(cfa$mean_alpha)[3]),
    x = "Highest posterior density interval",
    y = "variable"
  )
```

In the SEM example above, all intervals regarding the loading estimates from the conceptual relationships do not include zero. 

### Equal tails interval

Alternatively, it is possible to access equal tails credibility intevals using the `bayesplot` package:

````{r, message = F, message = F}
library("bayesplot")
```

- `find` help us finding the loading values that have been previously determined to estimate the latent scores:

```{r, eval =F}
find <- paste0("alpha[", which(lnames %in% unlist(cfa$blocks)), ",", rep(1:length(cfa$blocks), lengths(cfa$blocks)), "]")

dt <- dt[find, ]
```

- The equal tails intervals are:

````{r, warning = F}
gridExtra::grid.arrange(mcmc_areas(cfa$posterior$alpha[, , find]),
  mcmc_intervals(cfa$posterior$alpha[, , find]),
  layout_matrix = matrix(c(1, 1, 2, 2), ncol = 2)
)
````

In addition to the possibilities for intervals, other `mcmc_.` graphs are recommended, several options include histograms, violin plots, pair plots, and others.
